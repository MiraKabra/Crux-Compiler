package crux.ast;

import crux.ast.*;
import crux.ast.OpExpr.Operation;
import crux.pt.CruxBaseVisitor;
import crux.pt.CruxParser;
import crux.ast.types.*;
import crux.ast.SymbolTable.Symbol;
import org.antlr.v4.runtime.ParserRuleContext;

import java.io.PrintStream;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

/**
 * This class will convert the parse tree generated by ANTLR to AST It follows the visitor pattern
 * where decls will be by DeclVisitor Class Stmts will be resolved by StmtVisitor Class Exprs will
 * be resolved by ExprVisitor Class
 */

public final class ParseTreeLower {
  private final DeclVisitor declVisitor = new DeclVisitor();
  private final StmtVisitor stmtVisitor = new StmtVisitor();
  private final ExprVisitor exprVisitor = new ExprVisitor();

  private final SymbolTable symTab;

  public ParseTreeLower(PrintStream err) {
    symTab = new SymbolTable(err);
  }

  private static Position makePosition(ParserRuleContext ctx) {
    var start = ctx.start;
    return new Position(start.getLine());
  }

  /**
   *
   * @return True if any errors
   */
  public boolean hasEncounteredError() {
    return symTab.hasEncounteredError();
  }


  /**
   * Lower top-level parse tree to AST
   *
   * @return a {@link DeclList} object representing the top-level AST.
   */

  public DeclarationList lower(CruxParser.ProgramContext program) {

    List<Declaration> declarations = new ArrayList<>();

    CruxParser.DeclListContext declListContext =  program.declList();
    for(CruxParser.DeclContext declContext : declListContext.decl()){
      Declaration declaration = declContext.accept(declVisitor) ;
      declarations.add(declaration);
    }

    return new DeclarationList(makePosition(program), declarations);
  }



  /**
   * Lower stmt list by lower individual stmt into AST.
   *
   * @return a {@link StmtList} AST object.
   */

  
  // private StatementList lower(CruxParser.StmtListContext stmtList) { }
   

  /**
   * Similar to {@link #lower(CruxParser.StmtListContext)}, but handles symbol table as well.
   *
   * @return a {@link StmtList} AST object.
   */

  
  // private StatementList lower(CruxParser.StmtBlockContext stmtBlock) { }
   

  /**
   * A parse tree visitor to create AST nodes derived from {@link Declaration}
   */
  private final class DeclVisitor extends CruxBaseVisitor<Declaration> {
    /**
     * Visit a parse tree var decl and create an AST {@link VarariableDeclaration}
     *
     * @return an AST {@link VariableDeclaration}
     */

    public VariableDeclaration visitVarDecl(CruxParser.VarDeclContext ctx) {
      CruxParser.TypeContext t = ctx.type();
      Type type;
      if(t.getText().equals("bool")){
        type = new BoolType();
      }else{
        type = new IntType();
      }
      Position position = makePosition(ctx);
      Symbol symbol = symTab.add(position, ctx.Identifier().getText(), type);
      return new VariableDeclaration(position, symbol);
    }

    public Declaration visitArrayDecl(CruxParser.ArrayDeclContext ctx) {
      CruxParser.TypeContext t = ctx.type();
      Type type;
      int size = Integer.parseInt(ctx.Integer().getText());
      if(t.getText().equals("bool")){
        type = new ArrayType(size, new BoolType());
      }else{
        type = new ArrayType(size, new IntType());
      }
      Position position = makePosition(ctx);
      Symbol symbol = symTab.add(position, ctx.Identifier().getText(), type);
      return new ArrayDeclaration(position, symbol);
    }
    public Declaration visitFunctionDefn(CruxParser.FunctionDefnContext ctx) {
      CruxParser.TypeContext t = ctx.type();
      CruxParser.ParamListContext paramListContext = ctx.paramList();
      CruxParser.StmtBlockContext stmtBlockContext = ctx.stmtBlock();
      Type ret;
      if(t.getText().equals("bool")){
        ret = new BoolType();
      }else if(t.getText().equals("void")){
        ret = new VoidType();
      }else{
        ret = new IntType();
      }
      List<Type> list = new ArrayList<>();
      for(CruxParser.ParamContext paramContext: paramListContext.param()){
        if(paramContext.type().getText().equals("bool")){
          list.add(new BoolType());
        }else{
          list.add(new IntType());
        }
      }
      TypeList args = new TypeList(list);
      Type type = new FuncType(args, ret);

      Position position = makePosition(ctx);
      Symbol symbol = symTab.add(position, ctx.Identifier().getText(), type);
      List<Symbol> parameters = new ArrayList<>();

      //enter a new scope before adding the param symbols
      symTab.enter();
      for(CruxParser.ParamContext paramContext: paramListContext.param()){
        if(paramContext.type().getText().equals("bool")){
          parameters.add(symTab.add(makePosition(paramContext), paramContext.Identifier().getText(), new BoolType()));
        }else{
          parameters.add(symTab.add(makePosition(paramContext), paramContext.Identifier().getText(), new IntType()));
        }
      }
      //symTab.exit();
      CruxParser.StmtListContext stmtListContext = stmtBlockContext.stmtList();

      List<Statement> statementList = new ArrayList<>();
      for(CruxParser.StmtContext stmtContext : stmtListContext.stmt()){
        Statement statement = stmtContext.accept(stmtVisitor);
        statementList.add(statement);
      }
      StatementList statements = new StatementList(makePosition(stmtListContext), statementList);
      symTab.exit();
      return new FunctionDefinition(position, symbol, parameters, statements);
    }

  }


  /**
   * A parse tree visitor to create AST nodes derived from {@link Stmt}
   */

  private final class StmtVisitor extends CruxBaseVisitor<Statement> {
    /**
     * Visit a parse tree var decl and create an AST {@link VariableDeclaration}. Since
     * {@link VariableDeclaration} is both {@link Declaration} and {@link Statement}, we simply
     * delegate this to {@link DeclVisitor#visitArrayDecl(CruxParser.ArrayDeclContext)} which we
     * implement earlier.
     *
     * @return an AST {@link VariableDeclaration}
     */
    public Statement visitVarDecl(CruxParser.VarDeclContext ctx) {
      return declVisitor.visitVarDecl(ctx);
    }

    
    /**
     * Visit a parse tree assignment stmt and create an AST {@link Assignment}
     *
     * @return an AST {@link Assignment}
     */

    public Statement visitAssignStmt(CruxParser.AssignStmtContext ctx) {
      CruxParser.DesignatorContext designatorContext = ctx.designator();
      CruxParser.Expr0Context expr0Context = ctx.expr0();

      Position position = makePosition(ctx);
      Expression location = designatorContext.accept(exprVisitor);
      Expression value = expr0Context.accept(exprVisitor);
      return new Assignment(position, location, value);
    }

    
    /**
     * Visit a parse tree assignment nosemi stmt and create an AST {@link Assignment}
     *
     * @return an AST {@link Assignment}
     */
    public Statement visitAssignStmtNoSemi(CruxParser.AssignStmtNoSemiContext ctx) {
      CruxParser.DesignatorContext designatorContext = ctx.designator();
      CruxParser.Expr0Context expr0Context = ctx.expr0();

      Position position = makePosition(ctx);
      Expression location = designatorContext.accept(exprVisitor);
      Expression value = expr0Context.accept(exprVisitor);
      return new Assignment(position, location, value);
    }


    /**
     * Visit a parse tree call stmt and create an AST {@link Call}. Since {@link Call} is both
     * {@link Expression} and {@link Statementt}, we simply delegate this to
     * {@link ExprVisitor#visitCallExpr(CruxParser.CallExprContext)} that we will implement later.
     *
     * @return an AST {@link Call}
     */

    public Statement visitCallStmt(CruxParser.CallStmtContext ctx) {
      return exprVisitor.visitCallExpr(ctx.callExpr());
    }

    
    /**
     * Visit a parse tree if-else branch and create an AST {@link IfElseBranch}. The template code
     * shows partial implementations that visit the then block and else block recursively before
     * using those returned AST nodes to construct {@link IfElseBranch} object.
     *
     * @return an AST {@link IfElseBranch}
     */
    public Statement visitIfStmt(CruxParser.IfStmtContext ctx) {

      CruxParser.Expr0Context expr0Context = ctx.expr0();
      List<CruxParser.StmtBlockContext> stmtBlockContexts = ctx.stmtBlock();

      Position position = makePosition(ctx);

      Expression condition = exprVisitor.visitExpr0(expr0Context);
      List<Statement> then_statement_list = new ArrayList<>();
      List<Statement> else_statement_list = new ArrayList<>();

//      for(CruxParser.StmtContext stmtContext : stmtBlockContexts.get(0).stmtList().stmt()){
//        then_statement_list.add(stmtContext.accept(stmtVisitor));
//      }
//
//      for(CruxParser.StmtContext stmtContext : stmtBlockContexts.get(1).stmtList().stmt()){
//        else_statement_list.add(stmtContext.accept(stmtVisitor));
//      }
//
//      StatementList thenBlock = new StatementList(makePosition(stmtBlockContexts.get(0)), then_statement_list);
//      StatementList elseBlock = new StatementList(makePosition(stmtBlockContexts.get(1)), else_statement_list);
//
//      return new IfElseBranch(position, condition, thenBlock, elseBlock);
      symTab.enter();
      for(CruxParser.StmtContext stmtContext : stmtBlockContexts.get(0).stmtList().stmt()){
        then_statement_list.add(stmtContext.accept(stmtVisitor));
      }
      StatementList thenBlock = new StatementList(makePosition(stmtBlockContexts.get(0)), then_statement_list);
      symTab.exit();
      //StatementList elseBlock = null;
      StatementList elseBlock = new StatementList(makePosition(stmtBlockContexts.get(0)), new ArrayList<>());
      symTab.enter();
      if(stmtBlockContexts.size() > 1){
        for(CruxParser.StmtContext stmtContext : stmtBlockContexts.get(1).stmtList().stmt()){
          else_statement_list.add(stmtContext.accept(stmtVisitor));
        }
        elseBlock = new StatementList(makePosition(stmtBlockContexts.get(1)), else_statement_list);
      }
      symTab.exit();
      return new IfElseBranch(position, condition, thenBlock, elseBlock);
    }

     
    
    /**
     * Visit a parse tree for loop and create an AST {@link For}. You'll going to use a similar
     * techniques as {@link #visitIfStmt(CruxParser.IfStmtContext)} to decompose this construction.
     *
     * @return an AST {@link Loop}
     */
    public Statement visitForStmt(CruxParser.ForStmtContext ctx) {
      symTab.enter();
      CruxParser.AssignStmtContext assignStmtContext = ctx.assignStmt();
      CruxParser.Expr0Context expr0Context = ctx.expr0();
      CruxParser.AssignStmtNoSemiContext assignStmtNoSemiContext = ctx.assignStmtNoSemi();
      CruxParser.StmtBlockContext stmtBlockContext = ctx.stmtBlock();

      Position position = makePosition(ctx);
      Assignment init = (Assignment)assignStmtContext.accept(stmtVisitor);
      Expression cond = expr0Context.accept(exprVisitor);
      Assignment increment = (Assignment)assignStmtNoSemiContext.accept(stmtVisitor);

      List<Statement> statements = new ArrayList<>();
      for(CruxParser.StmtContext stmtContext : stmtBlockContext.stmtList().stmt()){
        statements.add(stmtContext.accept(stmtVisitor));
      }
      StatementList body = new StatementList(makePosition(stmtBlockContext), statements);
      symTab.exit();
      return new For(position, init, cond, increment, body);
    }

     

    /**
     * Visit a parse tree return stmt and create an AST {@link Return}. Here we show a simple
     * example of how to lower a simple parse tree construction.
     *
     * @return an AST {@link Return}
     */

    public Statement visitReturnStmt(CruxParser.ReturnStmtContext ctx) {
      CruxParser.Expr0Context expr0Context = ctx.expr0();
      Expression value = expr0Context.accept(exprVisitor);
      Position position = makePosition(ctx);
      return new Return(position, value);
    }

     
    
    /**
     * Creates a Break node
     */

    public Statement visitBreakStmt(CruxParser.BreakStmtContext ctx) {
      Position position = makePosition(ctx);
      return new Break(position);
    }

    
  }

  //'>=' | '<=' | '!=' | '==' | '>' | '<'
  private final class ExprVisitor extends CruxBaseVisitor<Expression> {
    /**
     * Parse Expr0 to OpExpr Node Parsing the expr should be exactly as described in the grammer
     */
    public Expression visitExpr0(CruxParser.Expr0Context ctx) {
      List<CruxParser.Expr1Context> expr1ContextList = ctx.expr1();
      CruxParser.Op0Context op0Context = ctx.op0();
      if(op0Context == null){
        return expr1ContextList.get(0).accept(exprVisitor);
      }else{
        Expression left = expr1ContextList.get(0).accept(exprVisitor);
        Expression right = expr1ContextList.get(1).accept(exprVisitor);
        Operation op = Operation.GE;
        switch (op0Context.getText()){
          case ">=":
            op = Operation.GE;
            break;
          case "<=":
            op = Operation.LE;
            break;
          case "!=":
            op = Operation.NE;
            break;
          case "==":
            op = Operation.EQ;
            break;
          case ">":
            op = Operation.GT;
            break;
          case "<":
            op = Operation.LT;
        }
        return new OpExpr(makePosition(ctx), op, left, right);
      }
    }

    /** '+' | '-' | '||' ;
     * Parse Expr1 to OpExpr Node Parsing the expr should be exactly as described in the grammer
     */
    public Expression visitExpr1(CruxParser.Expr1Context ctx) {
      CruxParser.Expr2Context expr2Context = ctx.expr2();
      CruxParser.Expr1Context expr1Context = ctx.expr1();
      CruxParser.Op1Context op1Context = ctx.op1();

      if(op1Context == null){
        return expr2Context.accept(exprVisitor);
      }else{
        Expression left = expr1Context.accept(exprVisitor);
        Expression right = expr2Context.accept(exprVisitor);
        Operation op = Operation.MULT;
        switch (op1Context.getText()){
          case "+":
            op = Operation.ADD;
            break;
          case "-":
            op = Operation.SUB;
            break;
          case "||":
            op = Operation.LOGIC_OR;
            break;
        }
        return new OpExpr(makePosition(ctx), op, left, right);
      }
    }


    /** op2 : '*' | '/' | '&&' ;
     * Parse Expr2 to OpExpr Node Parsing the expr should be exactly as described in the grammer
     */
    public Expression visitExpr2(CruxParser.Expr2Context ctx) {
      CruxParser.Expr3Context expr3Context = ctx.expr3();
      CruxParser.Expr2Context expr2Context = ctx.expr2();
      CruxParser.Op2Context op2Context = ctx.op2();

      if(op2Context == null){
        return expr3Context.accept(exprVisitor);
      }else{
        Expression left = expr2Context.accept(exprVisitor);
        Expression right = expr3Context.accept(exprVisitor);
        Operation op = Operation.MULT;
        switch (op2Context.getText()){
          case "*":
            op = Operation.MULT;
            break;
          case "/":
            op = Operation.DIV;
            break;
          case "&&":
            op = Operation.LOGIC_AND;
            break;
        }
        return new OpExpr(makePosition(ctx), op, left, right);
      }
    }


    /**
     * Parse Expr3 to OpExpr Node Parsing the expr should be exactly as described in the grammer
     */
     @Override
     public Expression visitExpr3(CruxParser.Expr3Context ctx) {
       CruxParser.Expr3Context expr3Context = ctx.expr3();
       CruxParser.Expr0Context expr0Context = ctx.expr0();
       CruxParser.DesignatorContext designatorContext = ctx.designator();
       CruxParser.CallExprContext callExprContext = ctx.callExpr();
       CruxParser.LiteralContext literalContext = ctx.literal();
       if(expr3Context != null){
         //return expr3Context.accept(exprVisitor);
         Expression expression = expr3Context.accept(exprVisitor);
         Operation operation = Operation.LOGIC_NOT;
         return new OpExpr(makePosition(ctx), operation, expression, null);
       }else if(expr0Context != null){
         return expr0Context.accept(exprVisitor);
       }else if(designatorContext != null){
         return designatorContext.accept(exprVisitor);
       }else if(callExprContext != null){
         return callExprContext.accept(exprVisitor);
       }else{
         return literalContext.accept(exprVisitor);
       }
     }

    /**
     * Create an Call Node
     */
     @Override
     public Call visitCallExpr(CruxParser.CallExprContext ctx) {
       Position position = makePosition(ctx);
       Symbol callee = symTab.lookup(makePosition(ctx), ctx.Identifier().getText());
       CruxParser.ExprListContext exprListContext = ctx.exprList();
       List<Expression> arguments = new ArrayList<>();
       for(CruxParser.Expr0Context expr0Context : exprListContext.expr0()){
         arguments.add(expr0Context.accept(exprVisitor));
       }
       return new Call(position, callee, arguments);
     }

    /**
     * visitDesignator will check for a name or ArrayAccess FYI it should account for the case when
     * the designator was dereferenced
     */
     @Override
     public Expression visitDesignator(CruxParser.DesignatorContext ctx) {

       CruxParser.Expr0Context expr0Context = ctx.expr0();
       Symbol symbol = symTab.lookup(makePosition(ctx), ctx.Identifier().getText());
       if(expr0Context == null){
         return new VarAccess(makePosition(ctx), symbol);
       }else{
         Expression expression = expr0Context.accept(exprVisitor);
         return new ArrayAccess(makePosition(ctx), symbol, expression);
       }
     }

    /**
     * Create an Literal Node
     */
     @Override
     public Expression visitLiteral(CruxParser.LiteralContext ctx) {
       Position position = makePosition(ctx);
       if(ctx.Integer() != null){
         return new LiteralInt(position, Long.parseLong(ctx.Integer().getText()));
       }else{
         if(ctx.True() != null){
           return new LiteralBool(position, true);
         }else{
           return new LiteralBool(position, false);
         }
       }
     }
  }
}
